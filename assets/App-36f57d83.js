import{B as On,V as L,a as Lt,P as Un,L as ft,T as It,S as Fn,M as yt,b as at,c as Vn,D as di,F as un,d as Ye,R as mi,r as B,u as W,e as nt,s as hi,j as k,f as X,g as F,C as gi,h as Qe,U as yi,i as fn,k as st,l as $t,m as me,n as Dn,E as he,o as qt,p as _i,q as xi,t as bi,v as pn,w as vi,x as ht,G as ye,y as jn,z as Je,A as wi,H as Ai,I as Pi,J as kt,K as Si,N as Ti,O as Ci}from"./index-7585685f.js";import{Vector3 as Bi,Vector2 as Mi,UniformsUtils as In,UniformsLib as dn,ShaderMaterial as Ei}from"//cdn.skypack.dev/three@0.130.1/build/three.module.js";import"//cdn.skypack.dev/three@0.130.1/examples/jsm/lines/LineSegmentsGeometry.js";const $n=0,ki=1,zi=2,mn=2,Se=1.25,hn=1,Xt=6*4+4+4,we=65535,Li=Math.pow(2,-24),Te=Symbol("SKIP_GENERATION");function Ni(t){return t.index?t.index.count:t.attributes.position.count}function Nt(t){return Ni(t)/3}function Ri(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}function Oi(t,e){if(!t.index){const n=t.attributes.position.count,i=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Ri(n,i);t.setIndex(new On(s,1));for(let c=0;c<n;c++)s[c]=c}}function Hn(t,e){const n=Nt(t),i=e||t.drawRange,s=i.start/3,c=(i.start+i.count)/3,r=Math.max(0,s),a=Math.min(n,c)-r;return[{offset:Math.floor(r),count:Math.floor(a)}]}function qn(t,e){if(!t.groups||!t.groups.length)return Hn(t,e);const n=[],i=new Set,s=e||t.drawRange,c=s.start/3,r=(s.start+s.count)/3;for(const o of t.groups){const f=o.start/3,u=(o.start+o.count)/3;i.add(Math.max(c,f)),i.add(Math.min(r,u))}const a=Array.from(i.values()).sort((o,f)=>o-f);for(let o=0;o<a.length-1;o++){const f=a[o],u=a[o+1];n.push({offset:Math.floor(f),count:Math.floor(u-f)})}return n}function Ui(t,e){const n=Nt(t),i=qn(t,e).sort((r,a)=>r.offset-a.offset),s=i[i.length-1];s.count=Math.min(n-s.offset,s.count);let c=0;return i.forEach(({count:r})=>c+=r),n!==c}function Ce(t,e,n,i,s){let c=1/0,r=1/0,a=1/0,o=-1/0,f=-1/0,u=-1/0,p=1/0,l=1/0,d=1/0,A=-1/0,P=-1/0,x=-1/0;for(let y=e*6,g=(e+n)*6;y<g;y+=6){const v=t[y+0],_=t[y+1],w=v-_,S=v+_;w<c&&(c=w),S>o&&(o=S),v<p&&(p=v),v>A&&(A=v);const T=t[y+2],m=t[y+3],h=T-m,b=T+m;h<r&&(r=h),b>f&&(f=b),T<l&&(l=T),T>P&&(P=T);const M=t[y+4],C=t[y+5],E=M-C,N=M+C;E<a&&(a=E),N>u&&(u=N),M<d&&(d=M),M>x&&(x=M)}i[0]=c,i[1]=r,i[2]=a,i[3]=o,i[4]=f,i[5]=u,s[0]=p,s[1]=l,s[2]=d,s[3]=A,s[4]=P,s[5]=x}function Fi(t,e=null,n=null,i=null){const s=t.attributes.position,c=t.index?t.index.array:null,r=Nt(t),a=s.normalized;let o;e===null?(o=new Float32Array(r*6*4),n=0,i=r):(o=e,n=n||0,i=i||r);const f=s.array,u=s.offset||0;let p=3;s.isInterleavedBufferAttribute&&(p=s.data.stride);const l=["getX","getY","getZ"];for(let d=n;d<n+i;d++){const A=d*3,P=d*6;let x=A+0,y=A+1,g=A+2;c&&(x=c[x],y=c[y],g=c[g]),a||(x=x*p+u,y=y*p+u,g=g*p+u);for(let v=0;v<3;v++){let _,w,S;a?(_=s[l[v]](x),w=s[l[v]](y),S=s[l[v]](g)):(_=f[x+v],w=f[y+v],S=f[g+v]);let T=_;w<T&&(T=w),S<T&&(T=S);let m=_;w>m&&(m=w),S>m&&(m=S);const h=(m-T)/2,b=v*2;o[P+b+0]=T+h,o[P+b+1]=h+(Math.abs(T)+h)*Li}}return o}function j(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function gn(t){let e=-1,n=-1/0;for(let i=0;i<3;i++){const s=t[i+3]-t[i];s>n&&(n=s,e=i)}return e}function yn(t,e){e.set(t)}function _n(t,e,n){let i,s;for(let c=0;c<3;c++){const r=c+3;i=t[c],s=e[c],n[c]=i<s?i:s,i=t[r],s=e[r],n[r]=i>s?i:s}}function Yt(t,e,n){for(let i=0;i<3;i++){const s=e[t+2*i],c=e[t+2*i+1],r=s-c,a=s+c;r<n[i]&&(n[i]=r),a>n[i+3]&&(n[i+3]=a)}}function Ot(t){const e=t[3]-t[0],n=t[4]-t[1],i=t[5]-t[2];return 2*(e*n+n*i+i*e)}const ut=32,Vi=(t,e)=>t.candidate-e.candidate,dt=new Array(ut).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Qt=new Float32Array(6);function Di(t,e,n,i,s,c){let r=-1,a=0;if(c===$n)r=gn(e),r!==-1&&(a=(e[r]+e[r+3])/2);else if(c===ki)r=gn(t),r!==-1&&(a=ji(n,i,s,r));else if(c===zi){const o=Ot(t);let f=Se*s;const u=i*6,p=(i+s)*6;for(let l=0;l<3;l++){const d=e[l],x=(e[l+3]-d)/ut;if(s<ut/4){const y=[...dt];y.length=s;let g=0;for(let _=u;_<p;_+=6,g++){const w=y[g];w.candidate=n[_+2*l],w.count=0;const{bounds:S,leftCacheBounds:T,rightCacheBounds:m}=w;for(let h=0;h<3;h++)m[h]=1/0,m[h+3]=-1/0,T[h]=1/0,T[h+3]=-1/0,S[h]=1/0,S[h+3]=-1/0;Yt(_,n,S)}y.sort(Vi);let v=s;for(let _=0;_<v;_++){const w=y[_];for(;_+1<v&&y[_+1].candidate===w.candidate;)y.splice(_+1,1),v--}for(let _=u;_<p;_+=6){const w=n[_+2*l];for(let S=0;S<v;S++){const T=y[S];w>=T.candidate?Yt(_,n,T.rightCacheBounds):(Yt(_,n,T.leftCacheBounds),T.count++)}}for(let _=0;_<v;_++){const w=y[_],S=w.count,T=s-w.count,m=w.leftCacheBounds,h=w.rightCacheBounds;let b=0;S!==0&&(b=Ot(m)/o);let M=0;T!==0&&(M=Ot(h)/o);const C=hn+Se*(b*S+M*T);C<f&&(r=l,f=C,a=w.candidate)}}else{for(let v=0;v<ut;v++){const _=dt[v];_.count=0,_.candidate=d+x+v*x;const w=_.bounds;for(let S=0;S<3;S++)w[S]=1/0,w[S+3]=-1/0}for(let v=u;v<p;v+=6){let S=~~((n[v+2*l]-d)/x);S>=ut&&(S=ut-1);const T=dt[S];T.count++,Yt(v,n,T.bounds)}const y=dt[ut-1];yn(y.bounds,y.rightCacheBounds);for(let v=ut-2;v>=0;v--){const _=dt[v],w=dt[v+1];_n(_.bounds,w.rightCacheBounds,_.rightCacheBounds)}let g=0;for(let v=0;v<ut-1;v++){const _=dt[v],w=_.count,S=_.bounds,m=dt[v+1].rightCacheBounds;w!==0&&(g===0?yn(S,Qt):_n(S,Qt,Qt)),g+=w;let h=0,b=0;g!==0&&(h=Ot(Qt)/o);const M=s-g;M!==0&&(b=Ot(m)/o);const C=hn+Se*(h*g+b*M);C<f&&(r=l,f=C,a=_.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:r,pos:a}}function ji(t,e,n,i){let s=0;for(let c=e,r=e+n;c<r;c++)s+=t[c*6+i*2];return s/n}class Be{constructor(){this.boundingData=new Float32Array(6)}}function Ii(t,e,n,i,s,c){let r=i,a=i+s-1;const o=c.pos,f=c.axis*2;for(;;){for(;r<=a&&n[r*6+f]<o;)r++;for(;r<=a&&n[a*6+f]>=o;)a--;if(r<a){for(let u=0;u<3;u++){let p=e[r*3+u];e[r*3+u]=e[a*3+u],e[a*3+u]=p}for(let u=0;u<6;u++){let p=n[r*6+u];n[r*6+u]=n[a*6+u],n[a*6+u]=p}r++,a--}else return r}}function $i(t,e,n,i,s,c){let r=i,a=i+s-1;const o=c.pos,f=c.axis*2;for(;;){for(;r<=a&&n[r*6+f]<o;)r++;for(;r<=a&&n[a*6+f]>=o;)a--;if(r<a){let u=t[r];t[r]=t[a],t[a]=u;for(let p=0;p<6;p++){let l=n[r*6+p];n[r*6+p]=n[a*6+p],n[a*6+p]=l}r++,a--}else return r}}function K(t,e){return e[t+15]===65535}function G(t,e){return e[t+6]}function Q(t,e){return e[t+14]}function J(t){return t+8}function tt(t,e){return e[t+6]}function Xn(t,e){return e[t+7]}let Wn,Ht,ge,Zn;const Hi=Math.pow(2,32);function je(t){return"count"in t?1:1+je(t.left)+je(t.right)}function qi(t,e,n){return Wn=new Float32Array(n),Ht=new Uint32Array(n),ge=new Uint16Array(n),Zn=new Uint8Array(n),Ie(t,e)}function Ie(t,e){const n=t/4,i=t/2,s="count"in e,c=e.boundingData;for(let r=0;r<6;r++)Wn[n+r]=c[r];if(s)if(e.buffer){const r=e.buffer;Zn.set(new Uint8Array(r),t);for(let a=t,o=t+r.byteLength;a<o;a+=Xt){const f=a/2;K(f,ge)||(Ht[a/4+6]+=n)}return t+r.byteLength}else{const r=e.offset,a=e.count;return Ht[n+6]=r,ge[i+14]=a,ge[i+15]=we,t+Xt}else{const r=e.left,a=e.right,o=e.splitAxis;let f;if(f=Ie(t+Xt,r),f/4>Hi)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ht[n+6]=f/4,f=Ie(f,a),Ht[n+7]=o,f}}function Xi(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,i=n>2**16,s=i?4:2,c=e?new SharedArrayBuffer(n*s):new ArrayBuffer(n*s),r=i?new Uint32Array(c):new Uint16Array(c);for(let a=0,o=r.length;a<o;a++)r[a]=a;return r}function Wi(t,e,n,i,s){const{maxDepth:c,verbose:r,maxLeafTris:a,strategy:o,onProgress:f,indirect:u}=s,p=t._indirectBuffer,l=t.geometry,d=l.index?l.index.array:null,A=u?$i:Ii,P=Nt(l),x=new Float32Array(6);let y=!1;const g=new Be;return Ce(e,n,i,g.boundingData,x),_(g,n,i,x),g;function v(w){f&&f(w/P)}function _(w,S,T,m=null,h=0){if(!y&&h>=c&&(y=!0,r&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),T<=a||h>=c)return v(S+T),w.offset=S,w.count=T,w;const b=Di(w.boundingData,m,e,S,T,o);if(b.axis===-1)return v(S+T),w.offset=S,w.count=T,w;const M=A(p,d,e,S,T,b);if(M===S||M===S+T)v(S+T),w.offset=S,w.count=T;else{w.splitAxis=b.axis;const C=new Be,E=S,N=M-S;w.left=C,Ce(e,E,N,C.boundingData,x),_(C,E,N,x,h+1);const O=new Be,R=M,q=T-N;w.right=O,Ce(e,R,q,O.boundingData,x),_(O,R,q,x,h+1)}return w}}function Zi(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=Xi(n,e.useSharedArrayBuffer),Ui(n,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||Oi(n,e);const i=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Fi(n),c=e.indirect?Hn(n,e.range):qn(n,e.range);t._roots=c.map(r=>{const a=Wi(t,s,r.offset,r.count,e),o=je(a),f=new i(Xt*o);return qi(0,a,f),f})}class pt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,n){let i=1/0,s=-1/0;for(let c=0,r=e.length;c<r;c++){const o=e[c][n];i=o<i?o:i,s=o>s?o:s}this.min=i,this.max=s}setFromPoints(e,n){let i=1/0,s=-1/0;for(let c=0,r=n.length;c<r;c++){const a=n[c],o=e.dot(a);i=o<i?o:i,s=o>s?o:s}this.min=i,this.max=s}isSeparated(e){return this.min>e.max||e.min>this.max}}pt.prototype.setFromBox=function(){const t=new L;return function(n,i){const s=i.min,c=i.max;let r=1/0,a=-1/0;for(let o=0;o<=1;o++)for(let f=0;f<=1;f++)for(let u=0;u<=1;u++){t.x=s.x*o+c.x*(1-o),t.y=s.y*f+c.y*(1-f),t.z=s.z*u+c.z*(1-u);const p=n.dot(t);r=Math.min(p,r),a=Math.max(p,a)}this.min=r,this.max=a}}();const Ki=function(){const t=new L,e=new L,n=new L;return function(s,c,r){const a=s.start,o=t,f=c.start,u=e;n.subVectors(a,f),t.subVectors(s.end,s.start),e.subVectors(c.end,c.start);const p=n.dot(u),l=u.dot(o),d=u.dot(u),A=n.dot(o),x=o.dot(o)*d-l*l;let y,g;x!==0?y=(p*l-A*d)/x:y=0,g=(p+y*l)/d,r.x=y,r.y=g}}(),tn=function(){const t=new Lt,e=new L,n=new L;return function(s,c,r,a){Ki(s,c,t);let o=t.x,f=t.y;if(o>=0&&o<=1&&f>=0&&f<=1){s.at(o,r),c.at(f,a);return}else if(o>=0&&o<=1){f<0?c.at(0,a):c.at(1,a),s.closestPointToPoint(a,!0,r);return}else if(f>=0&&f<=1){o<0?s.at(0,r):s.at(1,r),c.closestPointToPoint(r,!0,a);return}else{let u;o<0?u=s.start:u=s.end;let p;f<0?p=c.start:p=c.end;const l=e,d=n;if(s.closestPointToPoint(p,!0,e),c.closestPointToPoint(u,!0,n),l.distanceToSquared(p)<=d.distanceToSquared(u)){r.copy(l),a.copy(p);return}else{r.copy(u),a.copy(d);return}}}}(),Gi=function(){const t=new L,e=new L,n=new Un,i=new ft;return function(c,r){const{radius:a,center:o}=c,{a:f,b:u,c:p}=r;if(i.start=f,i.end=u,i.closestPointToPoint(o,!0,t).distanceTo(o)<=a||(i.start=f,i.end=p,i.closestPointToPoint(o,!0,t).distanceTo(o)<=a)||(i.start=u,i.end=p,i.closestPointToPoint(o,!0,t).distanceTo(o)<=a))return!0;const P=r.getPlane(n);if(Math.abs(P.distanceToPoint(o))<=a){const y=P.projectPoint(o,e);if(r.containsPoint(y))return!0}return!1}}(),Yi=1e-15;function Me(t){return Math.abs(t)<Yi}class rt extends It{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new pt),this.points=[this.a,this.b,this.c],this.sphere=new Fn,this.plane=new Un,this.needsUpdate=!0}intersectsSphere(e){return Gi(e,this)}update(){const e=this.a,n=this.b,i=this.c,s=this.points,c=this.satAxes,r=this.satBounds,a=c[0],o=r[0];this.getNormal(a),o.setFromPoints(a,s);const f=c[1],u=r[1];f.subVectors(e,n),u.setFromPoints(f,s);const p=c[2],l=r[2];p.subVectors(n,i),l.setFromPoints(p,s);const d=c[3],A=r[3];d.subVectors(i,e),A.setFromPoints(d,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,e),this.needsUpdate=!1}}rt.prototype.closestPointToSegment=function(){const t=new L,e=new L,n=new ft;return function(s,c=null,r=null){const{start:a,end:o}=s,f=this.points;let u,p=1/0;for(let l=0;l<3;l++){const d=(l+1)%3;n.start.copy(f[l]),n.end.copy(f[d]),tn(n,s,t,e),u=t.distanceToSquared(e),u<p&&(p=u,c&&c.copy(t),r&&r.copy(e))}return this.closestPointToPoint(a,t),u=a.distanceToSquared(t),u<p&&(p=u,c&&c.copy(t),r&&r.copy(a)),this.closestPointToPoint(o,t),u=o.distanceToSquared(t),u<p&&(p=u,c&&c.copy(t),r&&r.copy(o)),Math.sqrt(p)}}();rt.prototype.intersectsTriangle=function(){const t=new rt,e=new Array(3),n=new Array(3),i=new pt,s=new pt,c=new L,r=new L,a=new L,o=new L,f=new L,u=new ft,p=new ft,l=new ft,d=new L;function A(P,x,y){const g=P.points;let v=0,_=-1;for(let w=0;w<3;w++){const{start:S,end:T}=u;S.copy(g[w]),T.copy(g[(w+1)%3]),u.delta(r);const m=Me(x.distanceToPoint(S));if(Me(x.normal.dot(r))&&m){y.copy(u),v=2;break}const h=x.intersectLine(u,d);if(!h&&m&&d.copy(S),(h||m)&&!Me(d.distanceTo(T))){if(v<=1)(v===1?y.start:y.end).copy(d),m&&(_=v);else if(v>=2){(_===1?y.start:y.end).copy(d),v=2;break}if(v++,v===2&&_===-1)break}}return v}return function(x,y=null,g=!1){this.needsUpdate&&this.update(),x.isExtendedTriangle?x.needsUpdate&&x.update():(t.copy(x),t.update(),x=t);const v=this.plane,_=x.plane;if(Math.abs(v.normal.dot(_.normal))>1-1e-10){const w=this.satBounds,S=this.satAxes;n[0]=x.a,n[1]=x.b,n[2]=x.c;for(let h=0;h<4;h++){const b=w[h],M=S[h];if(i.setFromPoints(M,n),b.isSeparated(i))return!1}const T=x.satBounds,m=x.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let h=0;h<4;h++){const b=T[h],M=m[h];if(i.setFromPoints(M,e),b.isSeparated(i))return!1}for(let h=0;h<4;h++){const b=S[h];for(let M=0;M<4;M++){const C=m[M];if(c.crossVectors(b,C),i.setFromPoints(c,e),s.setFromPoints(c,n),i.isSeparated(s))return!1}}return y&&(g||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const w=A(this,_,p);if(w===1&&x.containsPoint(p.end))return y&&(y.start.copy(p.end),y.end.copy(p.end)),!0;if(w!==2)return!1;const S=A(x,v,l);if(S===1&&this.containsPoint(l.end))return y&&(y.start.copy(l.end),y.end.copy(l.end)),!0;if(S!==2)return!1;if(p.delta(a),l.delta(o),a.dot(o)<0){let E=l.start;l.start=l.end,l.end=E}const T=p.start.dot(a),m=p.end.dot(a),h=l.start.dot(a),b=l.end.dot(a),M=m<h,C=T<b;return T!==b&&h!==m&&M===C?!1:(y&&(f.subVectors(p.start,l.start),f.dot(a)>0?y.start.copy(p.start):y.start.copy(l.start),f.subVectors(p.end,l.end),f.dot(a)<0?y.end.copy(p.end):y.end.copy(l.end)),!0)}}}();rt.prototype.distanceToPoint=function(){const t=new L;return function(n){return this.closestPointToPoint(n,t),n.distanceTo(t)}}();rt.prototype.distanceToTriangle=function(){const t=new L,e=new L,n=["a","b","c"],i=new ft,s=new ft;return function(r,a=null,o=null){const f=a||o?i:null;if(this.intersectsTriangle(r,f))return(a||o)&&(a&&f.getCenter(a),o&&f.getCenter(o)),0;let u=1/0;for(let p=0;p<3;p++){let l;const d=n[p],A=r[d];this.closestPointToPoint(A,t),l=A.distanceToSquared(t),l<u&&(u=l,a&&a.copy(t),o&&o.copy(A));const P=this[d];r.closestPointToPoint(P,t),l=P.distanceToSquared(t),l<u&&(u=l,a&&a.copy(P),o&&o.copy(t))}for(let p=0;p<3;p++){const l=n[p],d=n[(p+1)%3];i.set(this[l],this[d]);for(let A=0;A<3;A++){const P=n[A],x=n[(A+1)%3];s.set(r[P],r[x]),tn(i,s,t,e);const y=t.distanceToSquared(e);y<u&&(u=y,a&&a.copy(t),o&&o.copy(e))}}return Math.sqrt(u)}}();class Z{constructor(e,n,i){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new yt,this.invMatrix=new yt,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new pt),this.alignedSatBounds=new Array(3).fill().map(()=>new pt),this.needsUpdate=!1,e&&this.min.copy(e),n&&this.max.copy(n),i&&this.matrix.copy(i)}set(e,n,i){this.min.copy(e),this.max.copy(n),this.matrix.copy(i),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}Z.prototype.update=function(){return function(){const e=this.matrix,n=this.min,i=this.max,s=this.points;for(let f=0;f<=1;f++)for(let u=0;u<=1;u++)for(let p=0;p<=1;p++){const l=1*f|2*u|4*p,d=s[l];d.x=f?i.x:n.x,d.y=u?i.y:n.y,d.z=p?i.z:n.z,d.applyMatrix4(e)}const c=this.satBounds,r=this.satAxes,a=s[0];for(let f=0;f<3;f++){const u=r[f],p=c[f],l=1<<f,d=s[l];u.subVectors(a,d),p.setFromPoints(u,s)}const o=this.alignedSatBounds;o[0].setFromPointsField(s,"x"),o[1].setFromPointsField(s,"y"),o[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();Z.prototype.intersectsBox=function(){const t=new pt;return function(n){this.needsUpdate&&this.update();const i=n.min,s=n.max,c=this.satBounds,r=this.satAxes,a=this.alignedSatBounds;if(t.min=i.x,t.max=s.x,a[0].isSeparated(t)||(t.min=i.y,t.max=s.y,a[1].isSeparated(t))||(t.min=i.z,t.max=s.z,a[2].isSeparated(t)))return!1;for(let o=0;o<3;o++){const f=r[o],u=c[o];if(t.setFromBox(f,n),u.isSeparated(t))return!1}return!0}}();Z.prototype.intersectsTriangle=function(){const t=new rt,e=new Array(3),n=new pt,i=new pt,s=new L;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(t.copy(r),t.update(),r=t);const a=this.satBounds,o=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let l=0;l<3;l++){const d=a[l],A=o[l];if(n.setFromPoints(A,e),d.isSeparated(n))return!1}const f=r.satBounds,u=r.satAxes,p=this.points;for(let l=0;l<3;l++){const d=f[l],A=u[l];if(n.setFromPoints(A,p),d.isSeparated(n))return!1}for(let l=0;l<3;l++){const d=o[l];for(let A=0;A<4;A++){const P=u[A];if(s.crossVectors(d,P),n.setFromPoints(s,e),i.setFromPoints(s,p),n.isSeparated(i))return!1}}return!0}}();Z.prototype.closestPointToPoint=function(){return function(e,n){return this.needsUpdate&&this.update(),n.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),n}}();Z.prototype.distanceToPoint=function(){const t=new L;return function(n){return this.closestPointToPoint(n,t),n.distanceTo(t)}}();Z.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map(()=>new ft),n=new Array(12).fill().map(()=>new ft),i=new L,s=new L;return function(r,a=0,o=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||f)&&(r.getCenter(s),this.closestPointToPoint(s,i),r.closestPointToPoint(i,s),o&&o.copy(i),f&&f.copy(s)),0;const u=a*a,p=r.min,l=r.max,d=this.points;let A=1/0;for(let x=0;x<8;x++){const y=d[x];s.copy(y).clamp(p,l);const g=y.distanceToSquared(s);if(g<A&&(A=g,o&&o.copy(y),f&&f.copy(s),g<u))return Math.sqrt(g)}let P=0;for(let x=0;x<3;x++)for(let y=0;y<=1;y++)for(let g=0;g<=1;g++){const v=(x+1)%3,_=(x+2)%3,w=y<<v|g<<_,S=1<<x|y<<v|g<<_,T=d[w],m=d[S];e[P].set(T,m);const b=t[x],M=t[v],C=t[_],E=n[P],N=E.start,O=E.end;N[b]=p[b],N[M]=y?p[M]:l[M],N[C]=g?p[C]:l[M],O[b]=l[b],O[M]=y?p[M]:l[M],O[C]=g?p[C]:l[M],P++}for(let x=0;x<=1;x++)for(let y=0;y<=1;y++)for(let g=0;g<=1;g++){s.x=x?l.x:p.x,s.y=y?l.y:p.y,s.z=g?l.z:p.z,this.closestPointToPoint(s,i);const v=s.distanceToSquared(i);if(v<A&&(A=v,o&&o.copy(i),f&&f.copy(s),v<u))return Math.sqrt(v)}for(let x=0;x<12;x++){const y=e[x];for(let g=0;g<12;g++){const v=n[g];tn(y,v,i,s);const _=i.distanceToSquared(s);if(_<A&&(A=_,o&&o.copy(i),f&&f.copy(s),_<u))return Math.sqrt(_)}}return Math.sqrt(A)}}();class en{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class Qi extends en{constructor(){super(()=>new rt)}}const et=new Qi;class Ji{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let n=null;this.setBuffer=i=>{n&&e.push(n),n=i,this.float32Array=new Float32Array(i),this.uint16Array=new Uint16Array(i),this.uint32Array=new Uint32Array(i)},this.clearBuffer=()=>{n=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const D=new Ji;let gt,zt;const bt=[],Jt=new en(()=>new at);function ts(t,e,n,i,s,c){gt=Jt.getPrimitive(),zt=Jt.getPrimitive(),bt.push(gt,zt),D.setBuffer(t._roots[e]);const r=$e(0,t.geometry,n,i,s,c);D.clearBuffer(),Jt.releasePrimitive(gt),Jt.releasePrimitive(zt),bt.pop(),bt.pop();const a=bt.length;return a>0&&(zt=bt[a-1],gt=bt[a-2]),r}function $e(t,e,n,i,s=null,c=0,r=0){const{float32Array:a,uint16Array:o,uint32Array:f}=D;let u=t*2;if(K(u,o)){const l=G(t,f),d=Q(u,o);return j(t,a,gt),i(l,d,!1,r,c+t,gt)}else{let b=function(C){const{uint16Array:E,uint32Array:N}=D;let O=C*2;for(;!K(O,E);)C=J(C),O=C*2;return G(C,N)},M=function(C){const{uint16Array:E,uint32Array:N}=D;let O=C*2;for(;!K(O,E);)C=tt(C,N),O=C*2;return G(C,N)+Q(O,E)};const l=J(t),d=tt(t,f);let A=l,P=d,x,y,g,v;if(s&&(g=gt,v=zt,j(A,a,g),j(P,a,v),x=s(g),y=s(v),y<x)){A=d,P=l;const C=x;x=y,y=C,g=v}g||(g=gt,j(A,a,g));const _=K(A*2,o),w=n(g,_,x,r+1,c+A);let S;if(w===mn){const C=b(A),N=M(A)-C;S=i(C,N,!0,r+1,c+A,g)}else S=w&&$e(A,e,n,i,s,c,r+1);if(S)return!0;v=zt,j(P,a,v);const T=K(P*2,o),m=n(v,T,y,r+1,c+P);let h;if(m===mn){const C=b(P),N=M(P)-C;h=i(C,N,!0,r+1,c+P,v)}else h=m&&$e(P,e,n,i,s,c,r+1);return!!h}}const Ut=new L,Ee=new L;function es(t,e,n={},i=0,s=1/0){const c=i*i,r=s*s;let a=1/0,o=null;if(t.shapecast({boundsTraverseOrder:u=>(Ut.copy(e).clamp(u.min,u.max),Ut.distanceToSquared(e)),intersectsBounds:(u,p,l)=>l<a&&l<r,intersectsTriangle:(u,p)=>{u.closestPointToPoint(e,Ut);const l=e.distanceToSquared(Ut);return l<a&&(Ee.copy(Ut),a=l,o=p),l<c}}),a===1/0)return null;const f=Math.sqrt(a);return n.point?n.point.copy(Ee):n.point=Ee.clone(),n.distance=f,n.faceIndex=o,n}const vt=new L,wt=new L,At=new L,te=new Lt,ee=new Lt,ne=new Lt,xn=new L,bn=new L,vn=new L,ie=new L;function ns(t,e,n,i,s,c,r,a){let o;if(c===Vn?o=t.intersectTriangle(i,n,e,!0,s):o=t.intersectTriangle(e,n,i,c!==di,s),o===null)return null;const f=t.origin.distanceTo(s);return f<r||f>a?null:{distance:f,point:s.clone()}}function is(t,e,n,i,s,c,r,a,o,f,u){vt.fromBufferAttribute(e,c),wt.fromBufferAttribute(e,r),At.fromBufferAttribute(e,a);const p=ns(t,vt,wt,At,ie,o,f,u);if(p){i&&(te.fromBufferAttribute(i,c),ee.fromBufferAttribute(i,r),ne.fromBufferAttribute(i,a),p.uv=It.getInterpolation(ie,vt,wt,At,te,ee,ne,new Lt)),s&&(te.fromBufferAttribute(s,c),ee.fromBufferAttribute(s,r),ne.fromBufferAttribute(s,a),p.uv1=It.getInterpolation(ie,vt,wt,At,te,ee,ne,new Lt)),n&&(xn.fromBufferAttribute(n,c),bn.fromBufferAttribute(n,r),vn.fromBufferAttribute(n,a),p.normal=It.getInterpolation(ie,vt,wt,At,xn,bn,vn,new L),p.normal.dot(t.direction)>0&&p.normal.multiplyScalar(-1));const l={a:c,b:r,c:a,normal:new L,materialIndex:0};It.getNormal(vt,wt,At,l.normal),p.face=l,p.faceIndex=c}return p}function Ae(t,e,n,i,s,c,r){const a=i*3;let o=a+0,f=a+1,u=a+2;const p=t.index;t.index&&(o=p.getX(o),f=p.getX(f),u=p.getX(u));const{position:l,normal:d,uv:A,uv1:P}=t.attributes,x=is(n,l,d,A,P,o,f,u,e,c,r);return x?(x.faceIndex=i,s&&s.push(x),x):null}function $(t,e,n,i){const s=t.a,c=t.b,r=t.c;let a=e,o=e+1,f=e+2;n&&(a=n.getX(a),o=n.getX(o),f=n.getX(f)),s.x=i.getX(a),s.y=i.getY(a),s.z=i.getZ(a),c.x=i.getX(o),c.y=i.getY(o),c.z=i.getZ(o),r.x=i.getX(f),r.y=i.getY(f),r.z=i.getZ(f)}function ss(t,e,n,i,s,c,r,a){const{geometry:o,_indirectBuffer:f}=t;for(let u=i,p=i+s;u<p;u++)Ae(o,e,n,u,c,r,a)}function rs(t,e,n,i,s,c,r){const{geometry:a,_indirectBuffer:o}=t;let f=1/0,u=null;for(let p=i,l=i+s;p<l;p++){let d;d=Ae(a,e,n,p,null,c,r),d&&d.distance<f&&(u=d,f=d.distance)}return u}function os(t,e,n,i,s,c,r){const{geometry:a}=n,{index:o}=a,f=a.attributes.position;for(let u=t,p=e+t;u<p;u++){let l;if(l=u,$(r,l*3,o,f),r.needsUpdate=!0,i(r,l,s,c))return!0}return!1}function cs(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,i=n.index?n.index.array:null,s=n.attributes.position;let c,r,a,o,f=0;const u=t._roots;for(let l=0,d=u.length;l<d;l++)c=u[l],r=new Uint32Array(c),a=new Uint16Array(c),o=new Float32Array(c),p(0,f),f+=c.byteLength;function p(l,d,A=!1){const P=l*2;if(a[P+15]===we){const y=r[l+6],g=a[P+14];let v=1/0,_=1/0,w=1/0,S=-1/0,T=-1/0,m=-1/0;for(let h=3*y,b=3*(y+g);h<b;h++){let M=i[h];const C=s.getX(M),E=s.getY(M),N=s.getZ(M);C<v&&(v=C),C>S&&(S=C),E<_&&(_=E),E>T&&(T=E),N<w&&(w=N),N>m&&(m=N)}return o[l+0]!==v||o[l+1]!==_||o[l+2]!==w||o[l+3]!==S||o[l+4]!==T||o[l+5]!==m?(o[l+0]=v,o[l+1]=_,o[l+2]=w,o[l+3]=S,o[l+4]=T,o[l+5]=m,!0):!1}else{const y=l+8,g=r[l+6],v=y+d,_=g+d;let w=A,S=!1,T=!1;e?w||(S=e.has(v),T=e.has(_),w=!S&&!T):(S=!0,T=!0);const m=w||S,h=w||T;let b=!1;m&&(b=p(y,d,w));let M=!1;h&&(M=p(g,d,w));const C=b||M;if(C)for(let E=0;E<3;E++){const N=y+E,O=g+E,R=o[N],q=o[N+3],ot=o[O],lt=o[O+3];o[l+E]=R<ot?R:ot,o[l+E+3]=q>lt?q:lt}return C}}}function _t(t,e,n,i,s){let c,r,a,o,f,u;const p=1/n.direction.x,l=1/n.direction.y,d=1/n.direction.z,A=n.origin.x,P=n.origin.y,x=n.origin.z;let y=e[t],g=e[t+3],v=e[t+1],_=e[t+3+1],w=e[t+2],S=e[t+3+2];return p>=0?(c=(y-A)*p,r=(g-A)*p):(c=(g-A)*p,r=(y-A)*p),l>=0?(a=(v-P)*l,o=(_-P)*l):(a=(_-P)*l,o=(v-P)*l),c>o||a>r||((a>c||isNaN(c))&&(c=a),(o<r||isNaN(r))&&(r=o),d>=0?(f=(w-x)*d,u=(S-x)*d):(f=(S-x)*d,u=(w-x)*d),c>u||f>r)?!1:((f>c||c!==c)&&(c=f),(u<r||r!==r)&&(r=u),c<=s&&r>=i)}function as(t,e,n,i,s,c,r,a){const{geometry:o,_indirectBuffer:f}=t;for(let u=i,p=i+s;u<p;u++){let l=f?f[u]:u;Ae(o,e,n,l,c,r,a)}}function ls(t,e,n,i,s,c,r){const{geometry:a,_indirectBuffer:o}=t;let f=1/0,u=null;for(let p=i,l=i+s;p<l;p++){let d;d=Ae(a,e,n,o?o[p]:p,null,c,r),d&&d.distance<f&&(u=d,f=d.distance)}return u}function us(t,e,n,i,s,c,r){const{geometry:a}=n,{index:o}=a,f=a.attributes.position;for(let u=t,p=e+t;u<p;u++){let l;if(l=n.resolveTriangleIndex(u),$(r,l*3,o,f),r.needsUpdate=!0,i(r,l,s,c))return!0}return!1}function fs(t,e,n,i,s,c,r){D.setBuffer(t._roots[e]),He(0,t,n,i,s,c,r),D.clearBuffer()}function He(t,e,n,i,s,c,r){const{float32Array:a,uint16Array:o,uint32Array:f}=D,u=t*2;if(K(u,o)){const l=G(t,f),d=Q(u,o);ss(e,n,i,l,d,s,c,r)}else{const l=J(t);_t(l,a,i,c,r)&&He(l,e,n,i,s,c,r);const d=tt(t,f);_t(d,a,i,c,r)&&He(d,e,n,i,s,c,r)}}const ps=["x","y","z"];function ds(t,e,n,i,s,c){D.setBuffer(t._roots[e]);const r=qe(0,t,n,i,s,c);return D.clearBuffer(),r}function qe(t,e,n,i,s,c){const{float32Array:r,uint16Array:a,uint32Array:o}=D;let f=t*2;if(K(f,a)){const p=G(t,o),l=Q(f,a);return rs(e,n,i,p,l,s,c)}else{const p=Xn(t,o),l=ps[p],A=i.direction[l]>=0;let P,x;A?(P=J(t),x=tt(t,o)):(P=tt(t,o),x=J(t));const g=_t(P,r,i,s,c)?qe(P,e,n,i,s,c):null;if(g){const w=g.point[l];if(A?w<=r[x+p]:w>=r[x+p+3])return g}const _=_t(x,r,i,s,c)?qe(x,e,n,i,s,c):null;return g&&_?g.distance<=_.distance?g:_:g||_||null}}const se=new at,Pt=new rt,St=new rt,Ft=new yt,wn=new Z,re=new Z;function ms(t,e,n,i){D.setBuffer(t._roots[e]);const s=Xe(0,t,n,i);return D.clearBuffer(),s}function Xe(t,e,n,i,s=null){const{float32Array:c,uint16Array:r,uint32Array:a}=D;let o=t*2;if(s===null&&(n.boundingBox||n.computeBoundingBox(),wn.set(n.boundingBox.min,n.boundingBox.max,i),s=wn),K(o,r)){const u=e.geometry,p=u.index,l=u.attributes.position,d=n.index,A=n.attributes.position,P=G(t,a),x=Q(o,r);if(Ft.copy(i).invert(),n.boundsTree)return j(t,c,re),re.matrix.copy(Ft),re.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:g=>re.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(i),g.b.applyMatrix4(i),g.c.applyMatrix4(i),g.needsUpdate=!0;for(let v=P*3,_=(x+P)*3;v<_;v+=3)if($(St,v,p,l),St.needsUpdate=!0,g.intersectsTriangle(St))return!0;return!1}});for(let y=P*3,g=(x+P)*3;y<g;y+=3){$(Pt,y,p,l),Pt.a.applyMatrix4(Ft),Pt.b.applyMatrix4(Ft),Pt.c.applyMatrix4(Ft),Pt.needsUpdate=!0;for(let v=0,_=d.count;v<_;v+=3)if($(St,v,d,A),St.needsUpdate=!0,Pt.intersectsTriangle(St))return!0}}else{const u=t+8,p=a[t+6];return j(u,c,se),!!(s.intersectsBox(se)&&Xe(u,e,n,i,s)||(j(p,c,se),s.intersectsBox(se)&&Xe(p,e,n,i,s)))}}const oe=new yt,ke=new Z,Vt=new Z,hs=new L,gs=new L,ys=new L,_s=new L;function xs(t,e,n,i={},s={},c=0,r=1/0){e.boundingBox||e.computeBoundingBox(),ke.set(e.boundingBox.min,e.boundingBox.max,n),ke.needsUpdate=!0;const a=t.geometry,o=a.attributes.position,f=a.index,u=e.attributes.position,p=e.index,l=et.getPrimitive(),d=et.getPrimitive();let A=hs,P=gs,x=null,y=null;s&&(x=ys,y=_s);let g=1/0,v=null,_=null;return oe.copy(n).invert(),Vt.matrix.copy(oe),t.shapecast({boundsTraverseOrder:w=>ke.distanceToBox(w),intersectsBounds:(w,S,T)=>T<g&&T<r?(S&&(Vt.min.copy(w.min),Vt.max.copy(w.max),Vt.needsUpdate=!0),!0):!1,intersectsRange:(w,S)=>{if(e.boundsTree)return e.boundsTree.shapecast({boundsTraverseOrder:m=>Vt.distanceToBox(m),intersectsBounds:(m,h,b)=>b<g&&b<r,intersectsRange:(m,h)=>{for(let b=m,M=m+h;b<M;b++){$(d,3*b,p,u),d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let C=w,E=w+S;C<E;C++){$(l,3*C,f,o),l.needsUpdate=!0;const N=l.distanceToTriangle(d,A,x);if(N<g&&(P.copy(A),y&&y.copy(x),g=N,v=C,_=b),N<c)return!0}}}});{const T=Nt(e);for(let m=0,h=T;m<h;m++){$(d,3*m,p,u),d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let b=w,M=w+S;b<M;b++){$(l,3*b,f,o),l.needsUpdate=!0;const C=l.distanceToTriangle(d,A,x);if(C<g&&(P.copy(A),y&&y.copy(x),g=C,v=b,_=m),C<c)return!0}}}}}),et.releasePrimitive(l),et.releasePrimitive(d),g===1/0?null:(i.point?i.point.copy(P):i.point=P.clone(),i.distance=g,i.faceIndex=v,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(oe),P.applyMatrix4(oe),s.distance=P.sub(s.point).length(),s.faceIndex=_),i)}function bs(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,i=n.index?n.index.array:null,s=n.attributes.position;let c,r,a,o,f=0;const u=t._roots;for(let l=0,d=u.length;l<d;l++)c=u[l],r=new Uint32Array(c),a=new Uint16Array(c),o=new Float32Array(c),p(0,f),f+=c.byteLength;function p(l,d,A=!1){const P=l*2;if(a[P+15]===we){const y=r[l+6],g=a[P+14];let v=1/0,_=1/0,w=1/0,S=-1/0,T=-1/0,m=-1/0;for(let h=y,b=y+g;h<b;h++){const M=3*t.resolveTriangleIndex(h);for(let C=0;C<3;C++){let E=M+C;E=i?i[E]:E;const N=s.getX(E),O=s.getY(E),R=s.getZ(E);N<v&&(v=N),N>S&&(S=N),O<_&&(_=O),O>T&&(T=O),R<w&&(w=R),R>m&&(m=R)}}return o[l+0]!==v||o[l+1]!==_||o[l+2]!==w||o[l+3]!==S||o[l+4]!==T||o[l+5]!==m?(o[l+0]=v,o[l+1]=_,o[l+2]=w,o[l+3]=S,o[l+4]=T,o[l+5]=m,!0):!1}else{const y=l+8,g=r[l+6],v=y+d,_=g+d;let w=A,S=!1,T=!1;e?w||(S=e.has(v),T=e.has(_),w=!S&&!T):(S=!0,T=!0);const m=w||S,h=w||T;let b=!1;m&&(b=p(y,d,w));let M=!1;h&&(M=p(g,d,w));const C=b||M;if(C)for(let E=0;E<3;E++){const N=y+E,O=g+E,R=o[N],q=o[N+3],ot=o[O],lt=o[O+3];o[l+E]=R<ot?R:ot,o[l+E+3]=q>lt?q:lt}return C}}}function vs(t,e,n,i,s,c,r){D.setBuffer(t._roots[e]),We(0,t,n,i,s,c,r),D.clearBuffer()}function We(t,e,n,i,s,c,r){const{float32Array:a,uint16Array:o,uint32Array:f}=D,u=t*2;if(K(u,o)){const l=G(t,f),d=Q(u,o);as(e,n,i,l,d,s,c,r)}else{const l=J(t);_t(l,a,i,c,r)&&We(l,e,n,i,s,c,r);const d=tt(t,f);_t(d,a,i,c,r)&&We(d,e,n,i,s,c,r)}}const ws=["x","y","z"];function As(t,e,n,i,s,c){D.setBuffer(t._roots[e]);const r=Ze(0,t,n,i,s,c);return D.clearBuffer(),r}function Ze(t,e,n,i,s,c){const{float32Array:r,uint16Array:a,uint32Array:o}=D;let f=t*2;if(K(f,a)){const p=G(t,o),l=Q(f,a);return ls(e,n,i,p,l,s,c)}else{const p=Xn(t,o),l=ws[p],A=i.direction[l]>=0;let P,x;A?(P=J(t),x=tt(t,o)):(P=tt(t,o),x=J(t));const g=_t(P,r,i,s,c)?Ze(P,e,n,i,s,c):null;if(g){const w=g.point[l];if(A?w<=r[x+p]:w>=r[x+p+3])return g}const _=_t(x,r,i,s,c)?Ze(x,e,n,i,s,c):null;return g&&_?g.distance<=_.distance?g:_:g||_||null}}const ce=new at,Tt=new rt,Ct=new rt,Dt=new yt,An=new Z,ae=new Z;function Ps(t,e,n,i){D.setBuffer(t._roots[e]);const s=Ke(0,t,n,i);return D.clearBuffer(),s}function Ke(t,e,n,i,s=null){const{float32Array:c,uint16Array:r,uint32Array:a}=D;let o=t*2;if(s===null&&(n.boundingBox||n.computeBoundingBox(),An.set(n.boundingBox.min,n.boundingBox.max,i),s=An),K(o,r)){const u=e.geometry,p=u.index,l=u.attributes.position,d=n.index,A=n.attributes.position,P=G(t,a),x=Q(o,r);if(Dt.copy(i).invert(),n.boundsTree)return j(t,c,ae),ae.matrix.copy(Dt),ae.needsUpdate=!0,n.boundsTree.shapecast({intersectsBounds:g=>ae.intersectsBox(g),intersectsTriangle:g=>{g.a.applyMatrix4(i),g.b.applyMatrix4(i),g.c.applyMatrix4(i),g.needsUpdate=!0;for(let v=P,_=x+P;v<_;v++)if($(Ct,3*e.resolveTriangleIndex(v),p,l),Ct.needsUpdate=!0,g.intersectsTriangle(Ct))return!0;return!1}});for(let y=P,g=x+P;y<g;y++){const v=e.resolveTriangleIndex(y);$(Tt,3*v,p,l),Tt.a.applyMatrix4(Dt),Tt.b.applyMatrix4(Dt),Tt.c.applyMatrix4(Dt),Tt.needsUpdate=!0;for(let _=0,w=d.count;_<w;_+=3)if($(Ct,_,d,A),Ct.needsUpdate=!0,Tt.intersectsTriangle(Ct))return!0}}else{const u=t+8,p=a[t+6];return j(u,c,ce),!!(s.intersectsBox(ce)&&Ke(u,e,n,i,s)||(j(p,c,ce),s.intersectsBox(ce)&&Ke(p,e,n,i,s)))}}const le=new yt,ze=new Z,jt=new Z,Ss=new L,Ts=new L,Cs=new L,Bs=new L;function Ms(t,e,n,i={},s={},c=0,r=1/0){e.boundingBox||e.computeBoundingBox(),ze.set(e.boundingBox.min,e.boundingBox.max,n),ze.needsUpdate=!0;const a=t.geometry,o=a.attributes.position,f=a.index,u=e.attributes.position,p=e.index,l=et.getPrimitive(),d=et.getPrimitive();let A=Ss,P=Ts,x=null,y=null;s&&(x=Cs,y=Bs);let g=1/0,v=null,_=null;return le.copy(n).invert(),jt.matrix.copy(le),t.shapecast({boundsTraverseOrder:w=>ze.distanceToBox(w),intersectsBounds:(w,S,T)=>T<g&&T<r?(S&&(jt.min.copy(w.min),jt.max.copy(w.max),jt.needsUpdate=!0),!0):!1,intersectsRange:(w,S)=>{if(e.boundsTree){const T=e.boundsTree;return T.shapecast({boundsTraverseOrder:m=>jt.distanceToBox(m),intersectsBounds:(m,h,b)=>b<g&&b<r,intersectsRange:(m,h)=>{for(let b=m,M=m+h;b<M;b++){const C=T.resolveTriangleIndex(b);$(d,3*C,p,u),d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let E=w,N=w+S;E<N;E++){const O=t.resolveTriangleIndex(E);$(l,3*O,f,o),l.needsUpdate=!0;const R=l.distanceToTriangle(d,A,x);if(R<g&&(P.copy(A),y&&y.copy(x),g=R,v=E,_=b),R<c)return!0}}}})}else{const T=Nt(e);for(let m=0,h=T;m<h;m++){$(d,3*m,p,u),d.a.applyMatrix4(n),d.b.applyMatrix4(n),d.c.applyMatrix4(n),d.needsUpdate=!0;for(let b=w,M=w+S;b<M;b++){const C=t.resolveTriangleIndex(b);$(l,3*C,f,o),l.needsUpdate=!0;const E=l.distanceToTriangle(d,A,x);if(E<g&&(P.copy(A),y&&y.copy(x),g=E,v=b,_=m),E<c)return!0}}}}}),et.releasePrimitive(l),et.releasePrimitive(d),g===1/0?null:(i.point?i.point.copy(P):i.point=P.clone(),i.distance=g,i.faceIndex=v,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(le),P.applyMatrix4(le),s.distance=P.sub(s.point).length(),s.faceIndex=_),i)}function Es(){return typeof SharedArrayBuffer<"u"}const Wt=new D.constructor,_e=new D.constructor,mt=new en(()=>new at),Bt=new at,Mt=new at,Le=new at,Ne=new at;let Re=!1;function ks(t,e,n,i){if(Re)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Re=!0;const s=t._roots,c=e._roots;let r,a=0,o=0;const f=new yt().copy(n).invert();for(let u=0,p=s.length;u<p;u++){Wt.setBuffer(s[u]),o=0;const l=mt.getPrimitive();j(0,Wt.float32Array,l),l.applyMatrix4(f);for(let d=0,A=c.length;d<A&&(_e.setBuffer(c[d]),r=it(0,0,n,f,i,a,o,0,0,l),_e.clearBuffer(),o+=c[d].length,!r);d++);if(mt.releasePrimitive(l),Wt.clearBuffer(),a+=s[u].length,r)break}return Re=!1,r}function it(t,e,n,i,s,c=0,r=0,a=0,o=0,f=null,u=!1){let p,l;u?(p=_e,l=Wt):(p=Wt,l=_e);const d=p.float32Array,A=p.uint32Array,P=p.uint16Array,x=l.float32Array,y=l.uint32Array,g=l.uint16Array,v=t*2,_=e*2,w=K(v,P),S=K(_,g);let T=!1;if(S&&w)u?T=s(G(e,y),Q(e*2,g),G(t,A),Q(t*2,P),o,r+e,a,c+t):T=s(G(t,A),Q(t*2,P),G(e,y),Q(e*2,g),a,c+t,o,r+e);else if(S){const m=mt.getPrimitive();j(e,x,m),m.applyMatrix4(n);const h=J(t),b=tt(t,A);j(h,d,Bt),j(b,d,Mt);const M=m.intersectsBox(Bt),C=m.intersectsBox(Mt);T=M&&it(e,h,i,n,s,r,c,o,a+1,m,!u)||C&&it(e,b,i,n,s,r,c,o,a+1,m,!u),mt.releasePrimitive(m)}else{const m=J(e),h=tt(e,y);j(m,x,Le),j(h,x,Ne);const b=f.intersectsBox(Le),M=f.intersectsBox(Ne);if(b&&M)T=it(t,m,n,i,s,c,r,a,o+1,f,u)||it(t,h,n,i,s,c,r,a,o+1,f,u);else if(b)if(w)T=it(t,m,n,i,s,c,r,a,o+1,f,u);else{const C=mt.getPrimitive();C.copy(Le).applyMatrix4(n);const E=J(t),N=tt(t,A);j(E,d,Bt),j(N,d,Mt);const O=C.intersectsBox(Bt),R=C.intersectsBox(Mt);T=O&&it(m,E,i,n,s,r,c,o,a+1,C,!u)||R&&it(m,N,i,n,s,r,c,o,a+1,C,!u),mt.releasePrimitive(C)}else if(M)if(w)T=it(t,h,n,i,s,c,r,a,o+1,f,u);else{const C=mt.getPrimitive();C.copy(Ne).applyMatrix4(n);const E=J(t),N=tt(t,A);j(E,d,Bt),j(N,d,Mt);const O=C.intersectsBox(Bt),R=C.intersectsBox(Mt);T=O&&it(h,E,i,n,s,r,c,o,a+1,C,!u)||R&&it(h,N,i,n,s,r,c,o,a+1,C,!u),mt.releasePrimitive(C)}}return T}const ue=new Z,Pn=new at,zs={strategy:$n,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class nn{static serialize(e,n={}){n={cloneBuffers:!0,...n};const i=e.geometry,s=e._roots,c=e._indirectBuffer,r=i.getIndex();let a;return n.cloneBuffers?a={roots:s.map(o=>o.slice()),index:r?r.array.slice():null,indirectBuffer:c?c.slice():null}:a={roots:s,index:r?r.array:null,indirectBuffer:c},a}static deserialize(e,n,i={}){i={setIndex:!0,indirect:!!e.indirectBuffer,...i};const{index:s,roots:c,indirectBuffer:r}=e,a=new nn(n,{...i,[Te]:!0});if(a._roots=c,a._indirectBuffer=r||null,i.setIndex){const o=n.getIndex();if(o===null){const f=new On(e.index,1,!1);n.setIndex(f)}else o.array!==s&&(o.array.set(s),o.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(e,n={}){if(e.isBufferGeometry){if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(n=Object.assign({...zs,[Te]:!1},n),n.useSharedArrayBuffer&&!Es())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,n[Te]||(Zi(this,n),!e.boundingBox&&n.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new at))),this.resolveTriangleIndex=n.indirect?i=>this._indirectBuffer[i]:i=>i}refit(e=null){return(this.indirect?bs:cs)(this,e)}traverse(e,n=0){const i=this._roots[n],s=new Uint32Array(i),c=new Uint16Array(i);r(0);function r(a,o=0){const f=a*2,u=c[f+15]===we;if(u){const p=s[a+6],l=c[f+14];e(o,u,new Float32Array(i,a*4,6),p,l)}else{const p=a+Xt/4,l=s[a+6],d=s[a+7];e(o,u,new Float32Array(i,a*4,6),d)||(r(p,o+1),r(l,o+1))}}}raycast(e,n=un,i=0,s=1/0){const c=this._roots,r=this.geometry,a=[],o=n.isMaterial,f=Array.isArray(n),u=r.groups,p=o?n.side:n,l=this.indirect?vs:fs;for(let d=0,A=c.length;d<A;d++){const P=f?n[u[d].materialIndex].side:p,x=a.length;if(l(this,d,P,e,a,i,s),f){const y=u[d].materialIndex;for(let g=x,v=a.length;g<v;g++)a[g].face.materialIndex=y}}return a}raycastFirst(e,n=un,i=0,s=1/0){const c=this._roots,r=this.geometry,a=n.isMaterial,o=Array.isArray(n);let f=null;const u=r.groups,p=a?n.side:n,l=this.indirect?As:ds;for(let d=0,A=c.length;d<A;d++){const P=o?n[u[d].materialIndex].side:p,x=l(this,d,P,e,i,s);x!=null&&(f==null||x.distance<f.distance)&&(f=x,o&&(x.face.materialIndex=u[d].materialIndex))}return f}intersectsGeometry(e,n){let i=!1;const s=this._roots,c=this.indirect?Ps:ms;for(let r=0,a=s.length;r<a&&(i=c(this,r,e,n),!i);r++);return i}shapecast(e){const n=et.getPrimitive(),i=this.indirect?us:os;let{boundsTraverseOrder:s,intersectsBounds:c,intersectsRange:r,intersectsTriangle:a}=e;if(r&&a){const p=r;r=(l,d,A,P,x)=>p(l,d,A,P,x)?!0:i(l,d,this,a,A,P,n)}else r||(a?r=(p,l,d,A)=>i(p,l,this,a,d,A,n):r=(p,l,d)=>d);let o=!1,f=0;const u=this._roots;for(let p=0,l=u.length;p<l;p++){const d=u[p];if(o=ts(this,p,c,r,s,f),o)break;f+=d.byteLength}return et.releasePrimitive(n),o}bvhcast(e,n,i){let{intersectsRanges:s,intersectsTriangles:c}=i;const r=et.getPrimitive(),a=this.geometry.index,o=this.geometry.attributes.position,f=this.indirect?A=>{const P=this.resolveTriangleIndex(A);$(r,P*3,a,o)}:A=>{$(r,A*3,a,o)},u=et.getPrimitive(),p=e.geometry.index,l=e.geometry.attributes.position,d=e.indirect?A=>{const P=e.resolveTriangleIndex(A);$(u,P*3,p,l)}:A=>{$(u,A*3,p,l)};if(c){const A=(P,x,y,g,v,_,w,S)=>{for(let T=y,m=y+g;T<m;T++){d(T),u.a.applyMatrix4(n),u.b.applyMatrix4(n),u.c.applyMatrix4(n),u.needsUpdate=!0;for(let h=P,b=P+x;h<b;h++)if(f(h),r.needsUpdate=!0,c(r,u,h,T,v,_,w,S))return!0}return!1};if(s){const P=s;s=function(x,y,g,v,_,w,S,T){return P(x,y,g,v,_,w,S,T)?!0:A(x,y,g,v,_,w,S,T)}}else s=A}return ks(this,e,n,s)}intersectsBox(e,n){return ue.set(e.min,e.max,n),ue.needsUpdate=!0,this.shapecast({intersectsBounds:i=>ue.intersectsBox(i),intersectsTriangle:i=>ue.intersectsTriangle(i)})}intersectsSphere(e){return this.shapecast({intersectsBounds:n=>e.intersectsBox(n),intersectsTriangle:n=>n.intersectsSphere(e)})}closestPointToGeometry(e,n,i={},s={},c=0,r=1/0){return(this.indirect?Ms:xs)(this,e,n,i,s,c,r)}closestPointToPoint(e,n={},i=0,s=1/0){return es(this,e,n,i,s)}getBoundingBox(e){return e.makeEmpty(),this._roots.forEach(i=>{j(0,new Float32Array(i),Pn),e.union(Pn)}),e}}function Sn(t,e,n){return t===null?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t)}const fe=new mi,Tn=new L,Cn=new yt,Ls=Ye.prototype.raycast,Ns=null,Bn=new L,H=new Ye,pe=[];function Rs(t,e){this.isBatchedMesh?Os.call(this,t,e):Us.call(this,t,e)}function Os(t,e){if(this.boundsTrees){const n=this.boundsTrees,i=this._drawInfo,s=this._drawRanges,c=this.matrixWorld;H.material=this.material,H.geometry=this.geometry;const r=H.geometry.boundsTree,a=H.geometry.drawRange;H.geometry.boundingSphere===null&&(H.geometry.boundingSphere=new Fn);for(let o=0,f=i.length;o<f;o++){if(!this.getVisibleAt(o))continue;const u=i[o].geometryIndex;if(H.geometry.boundsTree=n[u],this.getMatrixAt(o,H.matrixWorld).premultiply(c),!H.geometry.boundsTree){this.getBoundingBoxAt(u,H.geometry.boundingBox),this.getBoundingSphereAt(u,H.geometry.boundingSphere);const p=s[u];H.geometry.setDrawRange(p.start,p.count)}H.raycast(t,pe);for(let p=0,l=pe.length;p<l;p++){const d=pe[p];d.object=this,d.batchId=o,e.push(d)}pe.length=0}H.geometry.boundsTree=r,H.geometry.drawRange=a,H.material=null,H.geometry=null}else Ns.call(this,t,e)}function Us(t,e){if(this.geometry.boundsTree){if(this.material===void 0)return;Cn.copy(this.matrixWorld).invert(),fe.copy(t.ray).applyMatrix4(Cn),Bn.setFromMatrixScale(this.matrixWorld),Tn.copy(fe.direction).multiply(Bn);const n=Tn.length(),i=t.near/n,s=t.far/n,c=this.geometry.boundsTree;if(t.firstHitOnly===!0){const r=Sn(c.raycastFirst(fe,this.material,i,s),this,t);r&&e.push(r)}else{const r=c.raycast(fe,this.material,i,s);for(let a=0,o=r.length;a<o;a++){const f=Sn(r[a],this,t);f&&e.push(f)}}}else Ls.call(this,t,e)}function Fs(t={}){return this.boundsTree=new nn(this,t),this.boundsTree}function Vs(){this.boundsTree=null}function Ds(){const t=B.useRef(),e=W(s=>s.wiringStep);let{currentStepObject:n,setCurrentSVG:i}=B.useContext(nt);return B.useEffect(()=>{e&&document.getElementById("myEmbed").addEventListener("load",function(){i(hi(document.getElementById("myEmbed")))})},[e]),k(X,{children:e?k("div",{id:"svgContainer",style:{position:"absolute",width:"100%",height:"100%",bottom:"0px",left:"0px",padding:"10px"},children:k("embed",{style:{width:"100%",height:"100%",backgroundColor:"#e9e9e9"},ref:t,type:"image/svg+xml",src:`./${n.name}.svg`,id:"myEmbed"})}):null})}function js(){let{setStepPosition:t,stepCount:e,stepList:n}=B.useContext(nt);const i=()=>{e++,t(e)},s=()=>{e--,t(e)};return F(X,{children:[e>=1?k("button",{onClick:s,className:"btn",id:"nextStep",children:" ❮ Previous Step  "}):null,n&&e+1<=n.length-1?k("button",{onClick:i,className:"btn",id:"nextStep",children:"Next Step ❯ "}):null]})}function Is(){const{setModelInOut:t,selectedParts:e}=B.useContext(nt),[n,i]=B.useState(!1),s=W(r=>r.wiringStep);return k(X,{children:s?null:k("button",{onClick:()=>{n==!1?(document.getElementById("partsOut").innerHTML="Assemble",i(!0),t(n)):n==!0&&(document.getElementById("partsOut").innerHTML="Explode",i(!1),t(n))},className:"btn",id:"partsOut",children:"Explode"})})}class $s{constructor(e,n={}){this.enabled=!0;const i=n.defaultThickness!==void 0?n.defaultThickness:.003,s=new gi().fromArray(n.defaultColor!==void 0?n.defaultColor:[0,0,0]),c=n.defaultAlpha!==void 0?n.defaultAlpha:1,r=n.defaultKeepAlive!==void 0?n.defaultKeepAlive:!1,a={},o=60,f={},u={},p={outlineThickness:{value:i},outlineColor:{value:s},outlineAlpha:{value:c}},l=["#include <common>","#include <uv_pars_vertex>","#include <displacementmap_pars_vertex>","#include <fog_pars_vertex>","#include <morphtarget_pars_vertex>","#include <skinning_pars_vertex>","#include <logdepthbuf_pars_vertex>","#include <clipping_planes_pars_vertex>","uniform float outlineThickness;","vec4 calculateOutline( vec4 pos, vec3 normal, vec4 skinned ) {","	float thickness = outlineThickness;","	const float ratio = 1.0;","	vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + normal, 1.0 );","	vec4 norm = normalize( pos - pos2 );","	return pos + norm * thickness * pos.w * ratio;","}","void main() {","	#include <uv_vertex>","	#include <beginnormal_vertex>","	#include <morphnormal_vertex>","	#include <skinbase_vertex>","	#include <skinnormal_vertex>","	#include <begin_vertex>","	#include <morphtarget_vertex>","	#include <skinning_vertex>","	#include <displacementmap_vertex>","	#include <project_vertex>","	vec3 outlineNormal = - objectNormal;","	gl_Position = calculateOutline( gl_Position, outlineNormal, vec4( transformed, 1.0 ) );","	#include <logdepthbuf_vertex>","	#include <clipping_planes_vertex>","	#include <fog_vertex>","}"].join(`
`),d=["#include <common>","#include <fog_pars_fragment>","#include <logdepthbuf_pars_fragment>","#include <clipping_planes_pars_fragment>","uniform vec3 outlineColor;","uniform float outlineAlpha;","void main() {","	#include <clipping_planes_fragment>","	#include <logdepthbuf_fragment>","	gl_FragColor = vec4( outlineColor, outlineAlpha );","	#include <tonemapping_fragment>","	#include <encodings_fragment>","	#include <fog_fragment>","	#include <premultiplied_alpha_fragment>","}"].join(`
`);function A(){return new Qe({type:"OutlineEffect",uniforms:yi.merge([fn.fog,fn.displacementmap,p]),vertexShader:l,fragmentShader:d,side:Vn})}function P(m){let h=a[m.uuid];return h===void 0&&(h={material:A(),used:!0,keepAlive:r,count:0},a[m.uuid]=h),h.used=!0,h.material}function x(m){const h=P(m);return f[h.uuid]=m,S(h,m),h}function y(m){const h=m.geometry;let b=!1;return m.geometry!==void 0&&(h.isBufferGeometry?b=h.attributes.normal!==void 0:b=!0),m.isMesh===!0&&m.material!==void 0&&b===!0}function g(m){if(y(m)!==!1){if(Array.isArray(m.material))for(let h=0,b=m.material.length;h<b;h++)m.material[h]=x(m.material[h]);else m.material=x(m.material);u[m.uuid]=m.onBeforeRender,m.onBeforeRender=_}}function v(m){if(y(m)!==!1){if(Array.isArray(m.material))for(let h=0,b=m.material.length;h<b;h++)m.material[h]=f[m.material[h].uuid];else m.material=f[m.material.uuid];m.onBeforeRender=u[m.uuid]}}function _(m,h,b,M,C){const E=f[C.uuid];E!==void 0&&w(C,E)}function w(m,h){const b=h.userData.outlineParameters;m.uniforms.outlineAlpha.value=h.opacity,b!==void 0&&(b.thickness!==void 0&&(m.uniforms.outlineThickness.value=b.thickness),b.color!==void 0&&m.uniforms.outlineColor.value.fromArray(b.color),b.alpha!==void 0&&(m.uniforms.outlineAlpha.value=b.alpha)),h.displacementMap&&(m.uniforms.displacementMap.value=h.displacementMap,m.uniforms.displacementScale.value=h.displacementScale,m.uniforms.displacementBias.value=h.displacementBias)}function S(m,h){if(m.name==="invisible")return;const b=h.userData.outlineParameters;m.fog=h.fog,m.toneMapped=h.toneMapped,m.premultipliedAlpha=h.premultipliedAlpha,m.displacementMap=h.displacementMap,b!==void 0?(h.visible===!1?m.visible=!1:m.visible=b.visible!==void 0?b.visible:!0,m.transparent=b.alpha!==void 0&&b.alpha<1?!0:h.transparent,b.keepAlive!==void 0&&(a[h.uuid].keepAlive=b.keepAlive)):(m.transparent=h.transparent,m.visible=h.visible),(h.wireframe===!0||h.depthTest===!1)&&(m.visible=!1),h.clippingPlanes&&(m.clipping=!0,m.clippingPlanes=h.clippingPlanes,m.clipIntersection=h.clipIntersection,m.clipShadows=h.clipShadows),m.version=h.version}function T(){let m;m=Object.keys(f);for(let h=0,b=m.length;h<b;h++)f[m[h]]=void 0;m=Object.keys(u);for(let h=0,b=m.length;h<b;h++)u[m[h]]=void 0;m=Object.keys(a);for(let h=0,b=m.length;h<b;h++){const M=m[h];a[M].used===!1?(a[M].count++,a[M].keepAlive===!1&&a[M].count>o&&delete a[M]):(a[M].used=!1,a[M].count=0)}}this.render=function(m,h){if(this.enabled===!1){e.render(m,h);return}const b=e.autoClear;e.autoClear=this.autoClear,e.render(m,h),e.autoClear=b,this.renderOutline(m,h)},this.renderOutline=function(m,h){const b=e.autoClear,M=m.matrixWorldAutoUpdate,C=m.background,E=e.shadowMap.enabled;m.matrixWorldAutoUpdate=!1,m.background=null,e.autoClear=!1,e.shadowMap.enabled=!1,m.traverse(g),e.render(m,h),m.traverse(v),T(),m.matrixWorldAutoUpdate=M,m.background=C,e.autoClear=b,e.shadowMap.enabled=E},this.autoClear=e.autoClear,this.domElement=e.domElement,this.shadowMap=e.shadowMap,this.clear=function(m,h,b){e.clear(m,h,b)},this.getPixelRatio=function(){return e.getPixelRatio()},this.setPixelRatio=function(m){e.setPixelRatio(m)},this.getSize=function(m){return e.getSize(m)},this.setSize=function(m,h,b){e.setSize(m,h,b)},this.setViewport=function(m,h,b,M){e.setViewport(m,h,b,M)},this.setScissor=function(m,h,b,M){e.setScissor(m,h,b,M)},this.setScissorTest=function(m){e.setScissorTest(m)},this.setRenderTarget=function(m){e.setRenderTarget(m)}}}const Hs=B.createContext(null);function qs(t){let{children:e,enabled:n=!0}=t;const[i,s]=B.useState([]),c=B.useMemo(()=>({selected:i,select:s,enabled:n}),[i,s,n]);return st.createElement(Hs.Provider,{value:c},e)}function Xs({modelInCopy:t}){const e=new $t({color:15461355});var n=new me({color:10921638,linewidth:10});const i=new Qe(Dn);return i.uniforms.diffuse.value.set(0),B.useEffect(()=>{const s=[];t.traverse(c=>{if(c.frustumCulled=!0,c.isMesh){c.material=e,c.frustumCulled=!1;var r=new he(c.geometry,20),a=new qt(r,n);s.push(c.geometry);const o=new _i(xi(c.geometry)),f=new qt(o,i);c.add(a),c.add(f),r.dispose(),c.geometry.dispose(),e.dispose()}})},[]),k(X,{children:k("primitive",{object:t,scale:1})})}st.memo(Xs);new Bi;const Ws={linewidth:{value:1},resolution:{value:new Mi(1,1)},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1},opacity:{value:1}},Oe={uniforms:In.merge([dn.common,dn.fog,Ws]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 control0;
		attribute vec3 control1;
		attribute vec3 direction;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec2 ndcStart = clipStart.xy / clipStart.w;
			vec2 ndcEnd = clipEnd.xy / clipEnd.w;

			// direction
			vec2 dir = ndcEnd - ndcStart;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			// perpendicular to dir
			vec2 offset = vec2( dir.y, - dir.x );

			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

			// conditional logic
			// Transform the line segment ends and control points into camera clip space
			vec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );
			vec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );
			vec4 p0 = projectionMatrix * modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 p1 = projectionMatrix * modelViewMatrix * vec4( instanceStart + direction, 1.0 );

			c0 /= c0.w;
			c1 /= c1.w;
			p0 /= p0.w;
			p1 /= p1.w;

			// Get the direction of the segment and an orthogonal vector
			vec2 segDir = p1.xy - p0.xy;
			vec2 norm = vec2( - segDir.y, segDir.x );

			// Get control point directions from the line
			vec2 c0dir = c0.xy - p1.xy;
			vec2 c1dir = c1.xy - p1.xy;

			// If the vectors to the controls points are pointed in different directions away
			// from the line segment then the line should not be drawn.
			float d0 = dot( normalize( norm ), normalize( c0dir ) );
			float d1 = dot( normalize( norm ), normalize( c1dir ) );
			float discardFlag = float( sign( d0 ) != sign( d1 ) );
			gl_Position = discardFlag > 0.5 ? c0 : gl_Position;
			// end conditional line logic

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;

		#ifdef USE_DASH

			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

			vec4 diffuseColor = vec4( diffuse, opacity );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};class Zs extends Ei{constructor(e){super({type:"ConditionalLineMaterial",uniforms:In.clone(Oe.uniforms),vertexShader:Oe.vertexShader,fragmentShader:Oe.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(n){this.uniforms.diffuse.value=n}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(n){this.uniforms.linewidth.value=n}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(n){this.uniforms.dashScale.value=n}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(n){this.uniforms.dashSize.value=n}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(n){this.uniforms.gapSize.value=n}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(n){this.uniforms.opacity.value=n}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(n){this.uniforms.resolution.value.copy(n)}}}),this.setValues(e)}}Zs.prototype.isConditionalLineMaterial=!0;bi({OutlineEffect:$s});const Ue=[],Fe=[];function Ks({modelIn:t,modelOut:e,modelInCopy:n,modelInCopy2:i,modelOutCopy:s}){pn.prototype.computeBoundsTree=Fs,pn.prototype.disposeBoundsTree=Vs,Ye.prototype.raycast=Rs,console.log("render count");const{gl:c,camera:r,scene:a}=vi(),o=B.useRef(),f=B.useRef();B.useRef(),B.useRef(),B.useRef(),c.setPixelRatio(Math.min(window.devicePixelRatio,2));let{stepCount:u,modelProperties:p,partsInOut:l,setVisibleModel:d,setCurrentStepObj:A,currentStepObject:P,selectedParts:x,setProperties:y,setCurrentObject:g,visibleObj:v}=B.useContext(nt);const[_,w]=B.useState(!1),[S,T]=B.useState(!1),[m,h]=B.useState(i);B.useState();const[b,M]=B.useState(n);B.useState(i);const[C,E]=B.useState();B.useState(),B.useState();const[N,O]=B.useState(),[R,q]=B.useState();B.useState();const ot=new $t({color:15461355}),lt=new $t({color:16777215}),sn=new $t({color:16711680,wireframe:!0}),rn=new $t({color:13754592});var on=new me({color:4210752,linewidth:10}),cn=new me({color:6723993,linewidth:50}),ti=new me({color:10921638,linewidth:10});new Qe(Dn).uniforms.diffuse.value.set(0);const ei=[],Pe=[["012_Fix_back_left_corner_profile_linear_guide"],["021_Prepare_front_frame","022_Prepare_front_left_corner_profile","023_Fix_front_left_corner_profile","024_Fix_front_right_corner_profile","025_Fix_front_top_profile"],["10_Prepare_inner_panel_back"],["16_Prepare_Y_axis_beams"],["171_Prepare_gantry_back_left_corner_1","172_Prepare_gantry_back_left_corner_2","173_Prepare_gantry_back_left_corner_3"],["181_Prepare_gantry_back_right_corner_1","182_Prepare_gantry_back_right_corner_2","183_Prepare_gantry_back_right_corner_3"],["191_Prepare_gantry_front_left_corner_1","192_Prepare_gantry_front_left_corner_2"],["201_Prepare_gantry_front_right_corner_1","202_Prepare_gantry_front_right_corner_2"],["221_Prepare_X_left_connection_1","222_Prepare_X_left_connection_2"],["231_Prepare_X_right_connection_1","232_Prepare_X_right_connection_2"],["241_Prepare_X_axis_-_linear_guides","242_Prepare_X_axis_-_left_and_right_connections","243_Prepare_X_axis_-_carriages_attachments"],["271_Prepare_Z_motor_brackets_1","272_Prepare_Z_motor_brackets_2","273_Prepare_Z_motor_brackets_3"],["34_Prepare_head_bottom_holder"],["40_Prepare_the_camera"],["44_Prepare_back_panel"],["46_Prepare_back_side_panel"],["481_Prepare_the_bed","482_Fix_the_3D_Printing_Plates","483_Fix_bed_support_plates","484_Fix_the_bed_beams"],["501_Prepare_back_bottom_panel","502_Attach_back_bed_beam_support_panel"],["51_Prepare_front_bottom_panel"],["53_Prepare_front_right_panel_top"],["541_Prepare_front_right_panel_bottom_1","542_Prepare_front_right_panel_bottom_2"],["65_Prepare_electronic_covers"],["66_Prepare_left_side_bottom_panel"],["69_Prepare_front_doors"],["70_Prepare_side_doors"]],ni=[],an=[];let Gt=[],Rt=[];B.useEffect(()=>{l===!0?(h(i),q(i.getObjectByName(_[u]))):l===!1&&(h(s),q(s.getObjectByName(_[u])))},[l]),B.useEffect(()=>{m.traverse(z=>{z.isObject3D&&!z.isMesh&&!z.isGroup&&(Ue.push(z.name),Fe.push(z.userData.name))},[]),Ue.sort(),w(Ue),Fe.sort(),T(Fe),b.traverse(z=>{if(z.isMesh){z.material=ot,z.frustumCulled=!1;var I=new he(z.geometry,20),U=new qt(I,ti);z.add(U),z.geometry.dispose(),ot.dispose()}}),A(n.getObjectByName(_[0])),q(m.getObjectByName(_[0])),ln(),ht()},[]),ei.some(z=>z.includes(_[u]));const ii=Pe.some(z=>z.includes(_[u]));W(z=>z.wiringStep);const si=W(z=>z.isWiringStep),ri=W(z=>z.isNotWiringStep);ni.some(z=>z.includes(_[u]))?si():ri(),B.useEffect(()=>{A(i.getObjectByName(_[u])),q(m.getObjectByName(_[u]))},[_,u]),B.useEffect(()=>{console.log(P),ln()},[_,u,P]),B.useEffect(()=>{R&&(g(R.getObjectByName(_[u])),x!=[]&&li(),ht())},[x,R]);const ln=B.useCallback(()=>{let z=[],I=[];const U=[];if(P){for(let Y=0;Y<P.children.length;Y++)P.children[Y].traverse(xt=>{xt.isGroup&&xt.userData.name!=null&&U.push(xt.userData.name),z=[...new Set(U)],I=z.map(ct=>[U.filter(pi=>pi===ct).length,ct])});const V=P.userData.name;y({partsNames:I,titleName:V})}}),oi=B.useCallback(()=>{for(let z=u-1;z>=0;z--)for(let I=Rt.length-1;I>=0;I--)if(_[z]===Rt[I]){let U=b.getObjectByName(`${_[z]}`,!0);if(Gt.push(U),_[z+1]==="20_Attach_X_ball_screw_on_X_main_plate"){let V=b.getObjectByName("18_Prepare_X_main_plate",!0);Gt.push(V)}if(_[z+1]==="27_Fix_Z_ball_screw_on_Z_front_plate"){let V=b.getObjectByName("25_Prepare_Z_ball_screw",!0);Gt.push(V)}}}),ci=B.useCallback(()=>{for(let U=0;U<Pe.length;U++){Rt=Pe[U];for(let V=0;V<Rt.length;V++)Rt.some(xt=>xt.includes(_[u]))&&oi()}let z=new ye,I=R.clone();z.add(I),Gt.forEach(U=>{U.visible=!0;let V=U.clone();z.add(V)}),d(z)}),ai=B.useCallback(()=>{_[u]==="29_Fix_middle_plate_on_X-axis"&&b.getObjectByName("25_Prepare_Z_ball_screw",!0);for(let V=u-1;V>=0;V--){let Y=b.getObjectByName(`${_[V]}`,!0);an.push(Y)}let z=[];_[u]==="29_Fix_middle_plate_on_X-axis"&&(z=["25_Prepare_Z_ball_screw","26_Prepare_Z_front_plate","27_Fix_Z_ball_screw_on_Z_front_plate"],b.getObjectByName("25_Prepare_Z_ball_screw",!0),console.log("exception"));let I=new ye;an.filter(V=>!z.some(Y=>Y.includes(V.name))).forEach(V=>{V.visible=!0;let Y=V.clone();I.add(Y)});let U=R.clone();I.add(U),d(I)}),li=B.useCallback(()=>{if(R){const z=[];for(let I=0;I<R.children.length;I++)R.children[I].traverse(U=>{if(U.isMesh&&x.includes(R.children[I].userData.name)){U.frustumCulled=!1;const ct=U.geometry.clone();z.push(ct),U.material=rn;var V=new he(U.geometry,20),Y=new qt(V,cn);U.add(Y),rn.dispose(),V.dispose(),cn.dispose()}else if(U.isMesh&&R.children[I].userData.name!="Curves"){U.frustumCulled=!1,U.material=lt;var V=new he(U.geometry,20),xt=new qt(V,on);U.add(xt),V.dispose(),on.dispose()}else if(U.userData.name==="Curves"&&(U.material=sn,U.isGroup))for(let ct=0;ct<U.children.length;ct++)U.children[ct].isMesh&&(U.children[ct].frustumCulled=!1,U.children[ct].material=sn)});O(x)}});B.useCallback(()=>{C.traverse(z=>{z.name==="Botom_Panel"&&console.log(C.userData.name)})}),B.useCallback(z=>{z.stopPropagation(),console.log(z.object)});const ui=B.useCallback(()=>{if(R){R.clone();for(let z=0;z<m.children.length;z++)m.children[z].visible=!1;for(let z=0;z<b.children.length;z++)b.children[z].visible=!1;ii?(console.log("preparing step"),R.visible=!0,ci()):(console.log("main building step"),R.visible=!0,ai())}},[R]);B.useEffect(()=>{ui()},[R]);const{setListOfStep:fi}=B.useContext(nt);return fi(S),B.useState(null),k(X,{children:k(qs,{children:_?F(X,{children:[k("primitive",{ref:o,object:m,scale:1.0001}),k("primitive",{ref:f,object:b,scale:1})]}):null})})}const Gs=st.memo(Ks);function Ys(){let t=[],e=new ye;const{modelProperties:n,visibleObj:i,currentStepObject:s,setClickedParts:c,selectedParts:r,partsInOut:a,setCurrentPartsModel:o,currentObject:f,partBtnState:u,setPartButtonState:p}=B.useContext(nt),[l,d]=B.useState(null);B.useState(!1);const[A,P]=B.useState(!1),x=W(_=>_.wiringStep),y=B.useCallback(()=>{if(e=new ye,t=[],l){console.log(l);for(let _=0;_<f.children.length;_++)if(f.children[_].userData.name===l){const w=f.children[_].clone();e.add(w),t.push(f.children[_].userData.name)}c(t),o(e)}});B.useEffect(()=>{t=[],c(t),y()},[s,l]),B.useEffect(()=>{p(!1),t=[],c(t),o(null)},[s]);const g=()=>{u===!0&&(p(!1),t=[],c(t),o(null)),u===!1&&(p(!0),y())},v=()=>{console.log("disable"),p(!1),t=[],c(t),o(null),d(null)};return k(X,{children:k("div",{children:k("ul",{children:n?n.partsNames.map(([_,w],S)=>k("li",{children:w===l?F("button",{id:`${w}`,style:{backgroundColor:"#669999",color:"#ffffff"},disabled:A,onClick:()=>{u===!0&&v()},className:"parts",children:[F("b",{children:[" ",_,"x"]}),"  ",w]}):x?F("p",{style:{paddingBottom:10},children:[F("b",{children:[" ",_,"x"]}),"  ",w]}):F("button",{id:`${w}`,disabled:A,onClick:()=>{d(w),g()},className:"parts",children:[F("b",{children:[" ",_,"x "]}),"  ",w]})},S)):null})})})}function Qs(){const{modelProperties:t}=B.useContext(nt);return k(X,{children:k("div",{children:t?t.titleName:null})})}function Js(){const{stepList:t,setStepPosition:e,stepCount:n,currentStepName:i,modelProperties:s}=B.useContext(nt);B.useState("stepNaviBtn");const[c,r]=B.useState();return t&&[...Array(t.length)],k("div",{children:k("ul",{children:t?t.map((a,o)=>k("li",{children:s&&a===s.titleName?k("button",{id:`${a}`,style:{backgroundColor:"#000000",color:"#ffffff"},onClick:()=>{e(o)},className:"stepNaviBtn",children:a}):k("button",{id:`${a}`,style:{backgroundColor:c},onClick:()=>{e(o)},className:"stepNaviBtn",children:a})},o)):null})})}const tr=st.memo(Js);function er({cameraControlsRef:t}){let{visibleObj:e,modelProperties:n,selectedPartsModel:i,selectedParts:s,currentObject:c,setCamera:r,partBtnState:a,currentStepObject:o}=B.useContext(nt);const f=jn(),u=W(p=>p.cameraPositionTag);B.useEffect(()=>{e?(f.refresh(e).fit().clip(),ht()):(f.refresh(o).fit().clip(),ht())},[o,u]),B.useEffect(()=>{i?(f.refresh(i).fit(),ht()):i||(f.refresh(e).fit(),ht())},[i])}var Kn={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},Mn=st.createContext&&st.createContext(Kn),nr=["attr","size","title"];function ir(t,e){if(t==null)return{};var n=sr(t,e),i,s;if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(t);for(s=0;s<c.length;s++)i=c[s],!(e.indexOf(i)>=0)&&Object.prototype.propertyIsEnumerable.call(t,i)&&(n[i]=t[i])}return n}function sr(t,e){if(t==null)return{};var n={};for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)){if(e.indexOf(i)>=0)continue;n[i]=t[i]}return n}function xe(){return xe=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t},xe.apply(this,arguments)}function En(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter(function(s){return Object.getOwnPropertyDescriptor(t,s).enumerable})),n.push.apply(n,i)}return n}function be(t){for(var e=1;e<arguments.length;e++){var n=arguments[e]!=null?arguments[e]:{};e%2?En(Object(n),!0).forEach(function(i){rr(t,i,n[i])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):En(Object(n)).forEach(function(i){Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(n,i))})}return t}function rr(t,e,n){return e=or(e),e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function or(t){var e=cr(t,"string");return typeof e=="symbol"?e:e+""}function cr(t,e){if(typeof t!="object"||!t)return t;var n=t[Symbol.toPrimitive];if(n!==void 0){var i=n.call(t,e||"default");if(typeof i!="object")return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(t)}function Gn(t){return t&&t.map((e,n)=>st.createElement(e.tag,be({key:n},e.attr),Gn(e.child)))}function Kt(t){return e=>st.createElement(ar,xe({attr:be({},t.attr)},e),Gn(t.child))}function ar(t){var e=n=>{var{attr:i,size:s,title:c}=t,r=ir(t,nr),a=s||n.size||"1em",o;return n.className&&(o=n.className),t.className&&(o=(o?o+" ":"")+t.className),st.createElement("svg",xe({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},n.attr,i,r,{className:o,style:be(be({color:t.color||n.color},n.style),t.style),height:a,width:a,xmlns:"http://www.w3.org/2000/svg"}),c&&st.createElement("title",null,c),t.children)};return Mn!==void 0?st.createElement(Mn.Consumer,null,n=>e(n)):e(Kn)}function lr(t){return Kt({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"2",strokeLinecap:"round",strokeLinejoin:"round"},child:[{tag:"circle",attr:{cx:"12",cy:"12",r:"10"},child:[]},{tag:"line",attr:{x1:"12",x2:"12",y1:"8",y2:"12"},child:[]},{tag:"line",attr:{x1:"12",x2:"12.01",y1:"16",y2:"16"},child:[]}]})(t)}let Ge=1,Yn=new Array;new Array;let Ve=new Array,de;Je.get("https://sheets.googleapis.com/v4/spreadsheets/1ccaSIzLmGcbhfCR6b6uw5vEfHu1PzYjGlMEspaAizsE/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(t=>{let e=t.data.values,n=new Array;for(const i of e)Ge>2&&i[1]!=""&&(Yn.push(n),n=new Array),n.push(i),++Ge});function ur(){let{stepCount:t}=B.useContext(nt);return B.useEffect(()=>{de=new Array;for(const e of Yn[t+1])e[10]!=""&&e[10]!=null&&(Ve=new Array,Ve.push(e[10]),de.push(Ve)),++Ge},[t]),k(X,{children:de?F("div",{children:[F("div",{id:"RemarksTitle",style:{margin:"auto",display:"inline",alignContent:"baseline"},children:[F("h3",{children:[" ",k(lr,{})," Remarks"]})," ",k("br",{})]}),k("ul",{children:de.map((e,n)=>F("li",{children:[" ",e]},n))})]}):null})}/**
  * react-collapsed v4.2.0
  *
  * Copyright (c) 2019-2024, Rogin Farrer
  *
  * This source code is licensed under the MIT license found in the
  * LICENSE.md file in the root directory of this source tree.
  *
  * @license MIT
  */var fr=class extends Error{constructor(t){super(`react-collapsed: ${t}`)}},ve=(...t)=>(t[0],`${t[1]}`,void 0);function Qn(t){const e=B.useRef(t);return B.useEffect(()=>{e.current=t}),B.useCallback((...n)=>{var i;return(i=e.current)==null?void 0:i.call(e,...n)},[])}function pr(t,e,n){const[i,s]=B.useState(e),c=B.useRef(typeof t<"u"),r=c.current?t:i,a=Qn(n),o=B.useCallback(f=>{const p=typeof f=="function"?f(r):f;c.current||s(p),a==null||a(p)},[a,r]);return B.useEffect(()=>{ve(!(c.current&&t==null),"`isExpanded` state is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."),ve(!(!c.current&&t!=null),"`isExpanded` state is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.")},[t]),[r,o]}var dr="(prefers-reduced-motion: reduce)";function mr(){const[t,e]=B.useState(!1);return B.useEffect(()=>{if(typeof window>"u"||typeof window.matchMedia!="function")return;const n=window.matchMedia(dr);e(n.matches);const i=s=>{e(s.matches)};if(n.addEventListener)return n.addEventListener("change",i),()=>{n.removeEventListener("change",i)};if(n.addListener)return n.addListener(i),()=>{n.removeListener(i)}},[]),t}var hr=wi["useId".toString()]||(()=>{});function gr(){return hr()??""}var yr=typeof window<"u"?B.useLayoutEffect:B.useEffect,De=!1,_r=0,kn=()=>++_r;function xr(t){const e=t||(De?kn():null),[n,i]=B.useState(e);return yr(()=>{n===null&&i(kn())},[]),B.useEffect(()=>{De===!1&&(De=!0)},[]),n!=null?String(n):void 0}function br(t){const e=gr(),n=xr(t);return typeof t=="string"?t:typeof e=="string"?e:n}function vr(t,e){const n=performance.now(),i={};function s(){i.id=requestAnimationFrame(c=>{c-n>e?t():s()})}return s(),i}function zn(t){t.id&&cancelAnimationFrame(t.id)}function Ln(t){return t!=null&&t.current?t.current.scrollHeight:(ve(!0,"Was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\nconst collapseProps = getCollapseProps({refKey: 'innerRef'})"),0)}function wr(t){if(!t||typeof t=="string")return 0;const e=t/36;return Math.round((4+15*e**.25+e/5)*10)}function Ar(t,e){if(t!=null)if(typeof t=="function")t(e);else try{t.current=e}catch{throw new fr(`Cannot assign value "${e}" to ref "${t}"`)}}function Nn(...t){return t.every(e=>e==null)?null:e=>{t.forEach(n=>{Ar(n,e)})}}function Pr(t){let e=n=>{};e=n=>{if(!(n!=null&&n.current))return;const{paddingTop:i,paddingBottom:s}=window.getComputedStyle(n.current);ve(!(i&&i!=="0px"||s&&s!=="0px"),`Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element. Example:

Before:   <div {...getCollapseProps({style: {padding: 10}})}>{children}</div>

After:   <div {...getCollapseProps()}>
             <div style={{padding: 10}}>
                 {children}
             </div>
          </div>`)},B.useEffect(()=>{e(t)},[t])}var Sr=typeof window>"u"?B.useEffect:B.useLayoutEffect;function Tr({duration:t,easing:e="cubic-bezier(0.4, 0, 0.2, 1)",onTransitionStateChange:n=()=>{},isExpanded:i,defaultExpanded:s=!1,hasDisabledAnimation:c,id:r,...a}={}){const o=Qn(n),f=br(r?`${r}`:void 0),[u,p]=pr(i,s),l=B.useRef(u),[d,A]=B.useState(!1),P=mr(),x=c??P,y=B.useRef(),g=B.useRef(),v=B.useRef(null),[_,w]=B.useState(null);Pr(v);const S=`${a.collapsedHeight||0}px`;function T(m){if(!v.current)return;const h=v.current;for(const b in m){const M=m[b];M?h.style[b]=M:h.style.removeProperty(b)}}return Sr(()=>{if(!v.current||u===l.current)return;l.current=u;function h(C){return x?0:t??wr(C)}const b=C=>`height ${h(C)}ms ${e}`,M=C=>{function E(){u?(T({height:"",overflow:"",transition:"",display:""}),o("expandEnd")):(T({transition:""}),o("collapseEnd")),A(!1)}g.current&&zn(g.current),g.current=vr(E,C)};return A(!0),u?y.current=requestAnimationFrame(()=>{o("expandStart"),T({display:"block",overflow:"hidden",height:S}),y.current=requestAnimationFrame(()=>{o("expanding");const C=Ln(v);M(h(C)),v.current&&(v.current.style.transition=b(C),v.current.style.height=`${C}px`)})}):y.current=requestAnimationFrame(()=>{o("collapseStart");const C=Ln(v);M(h(C)),T({transition:b(C),height:`${C}px`}),y.current=requestAnimationFrame(()=>{o("collapsing"),T({height:S,overflow:"hidden"})})}),()=>{y.current&&cancelAnimationFrame(y.current),g.current&&zn(g.current)}},[u,S,x,t,e,o]),{isExpanded:u,setExpanded:p,getToggleProps(m){const{disabled:h,onClick:b,refKey:M,...C}={refKey:"ref",onClick(){},disabled:!1,...m},E=_?_.tagName==="BUTTON":void 0,N=m==null?void 0:m[M||"ref"],O={id:`react-collapsed-toggle-${f}`,"aria-controls":`react-collapsed-panel-${f}`,"aria-expanded":u,onClick(ot){h||(b==null||b(ot),p(lt=>!lt))},[M||"ref"]:Nn(N,w)},R={type:"button",disabled:h?!0:void 0},q={"aria-disabled":h?!0:void 0,role:"button",tabIndex:h?-1:0};return E===!1?{...O,...q,...C}:E===!0?{...O,...R,...C}:{...O,...R,...q,...C}},getCollapseProps(m){const{style:h,refKey:b}={refKey:"ref",style:{},...m},M=m==null?void 0:m[b||"ref"];return{id:`react-collapsed-panel-${f}`,"aria-hidden":!u,"aria-labelledby":`react-collapsed-toggle-${f}`,role:"region",...m,[b||"ref"]:Nn(v,M),style:{boxSizing:"border-box",...!d&&!u?{display:S==="0px"?"none":"block",height:S,overflow:"hidden"}:{},...h}}}}}function Cr(t){return Kt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"},child:[]},{tag:"path",attr:{d:"m18.25 7.6-5.5-3.18a1.49 1.49 0 0 0-1.5 0L5.75 7.6c-.46.27-.75.76-.75 1.3v6.35c0 .54.29 1.03.75 1.3l5.5 3.18c.46.27 1.04.27 1.5 0l5.5-3.18c.46-.27.75-.76.75-1.3V8.9c0-.54-.29-1.03-.75-1.3zM7 14.96v-4.62l4 2.32v4.61l-4-2.31zm5-4.03L8 8.61l4-2.31 4 2.31-4 2.32zm1 6.34v-4.61l4-2.32v4.62l-4 2.31zM7 2H3.5C2.67 2 2 2.67 2 3.5V7h2V4h3V2zm10 0h3.5c.83 0 1.5.67 1.5 1.5V7h-2V4h-3V2zM7 22H3.5c-.83 0-1.5-.67-1.5-1.5V17h2v3h3v2zm10 0h3.5c.83 0 1.5-.67 1.5-1.5V17h-2v3h-3v2z"},child:[]}]})(t)}function Br(t){return Kt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0V0z"},child:[]},{tag:"path",attr:{d:"m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14l-6-6z"},child:[]}]})(t)}function Mr(t){return Kt({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M24 24H0V0h24v24z",opacity:".87"},child:[]},{tag:"path",attr:{d:"M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6-1.41-1.41z"},child:[]}]})(t)}function Rn(t){return Kt({tag:"svg",attr:{viewBox:"0 0 1024 1024"},child:[{tag:"path",attr:{d:"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"},child:[]},{tag:"path",attr:{d:"M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0 1 30.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1 0 80 0 40 40 0 1 0-80 0z"},child:[]}]})(t)}let Zt=1,Jn=new Array,Et=new Array;Je.get("https://sheets.googleapis.com/v4/spreadsheets/1ccaSIzLmGcbhfCR6b6uw5vEfHu1PzYjGlMEspaAizsE/values/Workbook?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(t=>{let e=t.data.values,n=new Array;for(const i of e)Zt>2&&i[1]!=""&&(Jn.push(n),n=new Array),n.push(i),++Zt});function Er(){const[t,e]=B.useState(),[n,i]=B.useState(),[s,c]=B.useState(),r=W(d=>d.isNotVisibleToggle),a=W(d=>d.isVisibleToggle);W(d=>d.isVisible);let{stepCount:o,howToData:f,setHowToWorkbook:u,setClickedPath:p,path:l}=B.useContext(nt);return B.useEffect(()=>{let d=new Array;Je.get("https://sheets.googleapis.com/v4/spreadsheets/1grTucZ2sqLgZ4AtJq8EkyO__kLg-pazRVl3sbLNMaIY/values/Blad1?key=AIzaSyCqcO7MQv4dsj76ps3nNJnMwTT8Cvqv-eM").then(A=>{let P=A.data.values,x=new Array,y=[];for(const g of P)Zt>0&&g[0]!=""?(x=new Array,x.push(g),d.push(x)):x.push(g),++Zt;u(d);for(const g of d)g[0]!=""&&(Et=new Array,Et.push(g[0][0],g[0][1]),y.push(Et));c(y)})},[]),B.useEffect(()=>{let d=new Array;for(const A of Jn[o+1])A[12]!=""&&A[12]!=null&&(Et=new Array,Et.push(A[12]),d.push(Et)),++Zt;e(d)},[o]),B.useEffect(()=>{let d=[];if(s!=null){for(const A of t)for(const P of s)P.includes(`${A}`)&&d.push(P);i(d),t.length===0?r():a()}},[s,t]),k(X,{children:k("div",{children:k("ul",{children:n?n.map((d,A)=>F("li",{children:[k(Ai,{to:`/HowTo/${d[0]}`,target:"_blank",rel:"noopener noreferrer",children:F("button",{type:"button",className:"stepNaviBtn",children:[d[0],". ",d[1]]})})," "]},A)):null})})})}function kr(){const t=B.useRef(),[e,n]=B.useState(!1),{getCollapseProps:i,getToggleProps:s}=Tr({isExpanded:e}),c=W(r=>r.isVisible);return F(X,{children:[k("button",{type:"button",...s({onClick:()=>n(r=>!r)}),className:e?"expanded":"btn",style:{position:"absolute",top:"20px",left:"20px",visibility:`${c}`},children:e?F(X,{children:[k(Rn,{})," How To ",k(Br,{})]}):F(X,{children:[k(Rn,{})," How To ",k(Mr,{})]})}),k("div",{ref:t,className:"howToBoxContent",...i(),children:k(Er,{})})]})}function zr(){let{visibleObj:t,selectedParts:e,stepSVG:n}=B.useContext(nt);const i=W(u=>u.cameraPositionTag),s=W(u=>u.freeControls),c=W(u=>u.wiringStep),r=jn(),[a]=B.useState(()=>new L),[o]=B.useState(()=>new L),f=new L(4,1,8);return Pi((u,p)=>{i==="initial"&&c===!1&&(a.lerp(f,.1),o.lerp([0,0,0],.1),u.camera.position.copy(a),u.camera.lookAt(o),s(),r.refresh(t).fit(),ht()),i==="initial"&&c===!0&&(console.log(n),n.reset(),s(),ht())}),k(X,{})}function Fr(){const t=kt("./OLSK_Large_Printer_V2_All_In.glb"),e=kt("./OLSK_Large_Printer_V2_All_Out.glb"),n=B.useMemo(()=>t.scene.clone(),[t]),i=B.useMemo(()=>t.scene.clone(),[t]),s=B.useMemo(()=>e.scene.clone(),[e]);B.useState(!1),B.useRef(),B.useRef(),kt.clear("./OLSK_Large_Printer_V2_All_In.glb"),kt.clear("./OLSK_Large_Printer_V2_All_Out.glb");const c=W(r=>r.resetCamera);return k(X,{children:F(B.Fragment,{children:[k("aside",{className:"stepNavi",children:k(tr,{})}),F("section",{id:"currentStepArea",children:[F("nav",{className:"currentStepBar",children:[k("h2",{id:"stepTitleArea",children:k(Qs,{})}),F("div",{id:"stepControl",children:[k(js,{}),"                        "]})]}),F("div",{className:"infoColumn",children:[k("div",{className:"stepPartsArea",children:k(Ys,{})}),k("div",{className:"stepRemarksArea",children:k(ur,{})})]}),F("article",{className:"viewArea",id:"viewArea",children:[k(B.Suspense,{fallback:k("div",{children:"I am Loading"}),children:F(Si,{linear:!0,flat:!0,frameloop:"demand",camera:{fov:45,near:1,far:10,position:[4,1,8]},children:[k(Lr,{}),k("color",{args:["#f5f5f5"],attach:"background"}),F(Ti,{clip:!0,observe:!0,damping:2,margin:.85,children:[k(Gs,{modelIn:t,modelOut:e,modelInCopy:n,modelInCopy2:i,modelOutCopy:s}),k(er,{})]}),k(zr,{})]})}),k(Ds,{}),F("button",{className:"btn",style:{position:"absolute",bottom:"20px",left:"20px"},onClick:c,children:[k(Cr,{})," Reset Camera"]}),k(Is,{}),k(kr,{})]})]})]})})}kt.preload("./OLSK_Large_Printer_V2_All_In.glb");kt.preload("./OLSK_Large_Printer_V2_All_Out.glb");function Lr(){const t=B.useRef();return k(X,{children:k(Ci,{ref:t,makeDefault:!0,enableDamping:!1,enableRotate:!0,minAzimuthAngle:1/0,maxAzimuthAngle:1/0,minPolarAngle:0,maxPolarAngle:1/0})})}export{Fr as default};
//# sourceMappingURL=App-36f57d83.js.map
